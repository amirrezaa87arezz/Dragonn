import os
import json
import logging
from flask import Flask
from threading import Thread
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler

logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)

app_web = Flask('')
@app_web.route('/')
def home(): return "Dragon VPN System is Online!", 200

def run_web():
    port = int(os.environ.get('PORT', 8080))
    app_web.run(host='0.0.0.0', port=port)

# --- Ù…Ø¯ÛŒØ±ÛŒØª Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ---
DB_PATH = '/app/data'
DB_FILE = '/app/data/data.json'

def load_db():
    if not os.path.exists(DB_PATH): os.makedirs(DB_PATH, exist_ok=True)
    if os.path.exists(DB_FILE):
        try:
            with open(DB_FILE, 'r', encoding='utf-8') as f: return json.load(f)
        except: pass
    return {"users": {}, "card": {"number": "6277601368776066", "name": "Ø±Ø¶ÙˆØ§Ù†ÛŒ"}, "categories": {"Ø§Ø±Ø²Ø§Ù† Ùˆ Ø¨Ù‡ ØµØ±ÙÙ‡": [], "Ù‚ÙˆÛŒ": []}, "base_price": 50000}

def save_db(data):
    with open(DB_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=4)

db = load_db()
TOKEN = '8578186075:AAFevjClPyq2hAcJxJpwhrxc0DxxBMGN8RY'
ADMIN_ID = 5993860770
user_data = {} 

def get_main_menu(uid):
    kb = [['Ø®Ø±ÛŒØ¯ Ø§Ø´ØªØ±Ø§Ú©', 'ØªØ³Øª Ø±Ø§ÛŒÚ¯Ø§Ù†'], ['Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…Ù†'], ['Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ', 'Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø§ØªØµØ§Ù„']]
    if int(uid) == ADMIN_ID: kb.append(['âš™ï¸ Ù…Ø¯ÛŒØ±ÛŒØª Ø±Ø¨Ø§Øª'])
    return ReplyKeyboardMarkup(kb, resize_keyboard=True)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = str(update.message.from_user.id)
    if uid not in db["users"]:
        db["users"][uid] = {"purchases": [], "test_used": False, "raw_details": []}
        save_db(db)
    user_data[uid] = {}
    await update.message.reply_text("ğŸ‰ Ø¨Ù‡ Ø±Ø¨Ø§Øª Dragon VPN Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯", reply_markup=get_main_menu(uid))

async def handle_msg(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    uid = str(update.message.from_user.id)
    
    if text in ['âŒ Ø§Ù†ØµØ±Ø§Ù Ùˆ Ø¨Ø§Ø²Ú¯Ø´Øª', 'Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ']:
        user_data[uid] = {}
        await start(update, context)
        return

    # --- Ø¨Ø®Ø´ Ø§Ø¯Ù…ÛŒÙ† ---
    if int(uid) == ADMIN_ID:
        if text == 'âš™ï¸ Ù…Ø¯ÛŒØ±ÛŒØª Ø±Ø¨Ø§Øª':
            kb = [['Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ù„Ù†', 'Ø­Ø°Ù Ù¾Ù„Ù†'], ['ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±Øª', 'Ù¾ÛŒØ§Ù… Ù‡Ù…Ú¯Ø§Ù†ÛŒ'], ['Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ']]
            await update.message.reply_text("ğŸ›  Ù…Ø¯ÛŒØ±ÛŒØª Ø±Ø¨Ø§Øª:", reply_markup=ReplyKeyboardMarkup(kb, resize_keyboard=True))
            return
        
        # Ù„Ø§Ø¬ÛŒÚ© Ø­Ø°Ù Ù¾Ù„Ù†
        if text == 'Ø­Ø°Ù Ù¾Ù„Ù†':
            for cat, plans in db["categories"].items():
                for p in plans:
                    btn = [[InlineKeyboardButton(f"Ø­Ø°Ù {p['name']} ({cat})", callback_data=f"del_{cat}_{p['id']}")]]
                    await update.message.reply_text(f"Ù¾Ù„Ù†: {p['name']}", reply_markup=InlineKeyboardMarkup(btn))
            return

        # Ø§Ø±Ø³Ø§Ù„ Ú©Ø§Ù†ÙÛŒÚ¯
        if user_data.get(uid, {}).get('step') == 'send_cfg':
            info = user_data[uid]
            target = str(info['target'])
            # Ø°Ø®ÛŒØ±Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø±Ø§ÛŒ ØªÙ…Ø¯ÛŒØ¯Ù‡Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ
            db["users"][target]["purchases"].append(f"ğŸ“¦ {info['vol']} | ğŸ‘¤ {info['vpn_name']}")
            db["users"][target]["raw_details"].append({"vol": info['vol'], "price": info['price'], "name": info['vpn_name']})
            save_db(db)
            await context.bot.send_message(target, f"ğŸš€ Ø³Ø±ÙˆÛŒØ³ Ø´Ù…Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯:\n<code>{text}</code>", parse_mode='HTML')
            await update.message.reply_text("âœ… Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯."); user_data[uid] = {}
            return

    # --- Ø¨Ø®Ø´ Ú©Ø§Ø±Ø¨Ø± ---
    if user_data.get(uid, {}).get('step') == 'get_name':
        plan = user_data[uid]['plan']
        price = int(plan['price']) * 1000
        user_data[uid].update({'step': 'wait_pay', 'vpn_name': text, 'price': price, 'vol': plan['name']})
        invoice = f"ğŸ“‡ <b>Ù¾ÛŒØ´ ÙØ§Ú©ØªÙˆØ± Ø®Ø±ÛŒØ¯</b>\n\nğŸ‘¤ Ù†Ø§Ù…: {text}\nğŸ” Ù¾Ù„Ù†: {plan['name']}\nğŸ’¶ Ù…Ø¨Ù„Øº: {price:,} ØªÙˆÙ…Ø§Ù†"
        await update.message.reply_text(invoice, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ØªØ§ÛŒÛŒØ¯ Ùˆ Ù¾Ø±Ø¯Ø§Ø®Øª âœ…", callback_data="show_card")]]), parse_mode='HTML')
        return

    if text == 'Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…Ù†':
        purchases = db["users"].get(uid, {}).get("purchases", [])
        if not purchases: await update.message.reply_text("ğŸ“­ Ù„ÛŒØ³Øª Ø®Ø§Ù„ÛŒ Ø§Ø³Øª."); return
        for i, p in enumerate(purchases):
            await update.message.reply_text(f"âœ… {p}", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”„ ØªÙ…Ø¯ÛŒØ¯ Ù‡Ù…ÛŒÙ† Ø³Ø±ÙˆÛŒØ³", callback_data=f"ren_{i}")]]))

    elif text == 'Ø®Ø±ÛŒØ¯ Ø§Ø´ØªØ±Ø§Ú©':
        kb = [[c] for c in db["categories"].keys()]
        await update.message.reply_text("Ø§Ù†ØªØ®Ø§Ø¨ Ø¯Ø³ØªÙ‡:", reply_markup=ReplyKeyboardMarkup(kb, resize_keyboard=True))

    elif text in db["categories"]:
        plans = db["categories"][text]
        btn = [[InlineKeyboardButton(f"{p['name']} - {p['price']}Øª", callback_data=f"buy_{text}_{p['id']}")] for p in plans]
        await update.message.reply_text(f"Ù¾Ù„Ù†â€ŒÙ‡Ø§ÛŒ {text}:", reply_markup=InlineKeyboardMarkup(btn))

    elif text == 'Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ':
        await update.message.reply_text("ğŸ†˜ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ: @Dragon_Support")
    elif text == 'Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø§ØªØµØ§Ù„':
        await update.message.reply_text("ğŸ“š Ú©Ø§Ù†Ø§Ù„ Ø¢Ù…ÙˆØ²Ø´: @help_dragon")

async def handle_call(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; uid = str(query.from_user.id); await query.answer()
    
    # ØªÙ…Ø¯ÛŒØ¯ Ù‡ÙˆØ´Ù…Ù†Ø¯ (Ø¨Ø¯ÙˆÙ† Ø³ÙˆØ§Ù„ Ø§Ø¶Ø§ÙÙ‡)
    if query.data.startswith("ren_"):
        idx = int(query.data.split("_")[1])
        raw = db["users"][uid]["raw_details"][idx]
        user_data[uid] = {'step': 'wait_pay', 'vpn_name': raw['name'], 'vol': raw['vol'], 'price': raw['price'], 'is_new': False}
        invoice = f"ğŸ“‡ <b>Ù¾ÛŒØ´ ÙØ§Ú©ØªÙˆØ± ØªÙ…Ø¯ÛŒØ¯ Ø³Ø±ÙˆÛŒØ³</b>\n\nğŸ‘¤ Ø³Ø±ÙˆÛŒØ³: {raw['name']}\nğŸš€ Ø­Ø¬Ù…: {raw['vol']}\nğŸ’¶ Ù…Ø¨Ù„Øº ØªÙ…Ø¯ÛŒØ¯: {raw['price']:,} ØªÙˆÙ…Ø§Ù†\n\n(ØªÙ…Ø¯ÛŒØ¯ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø®Ø±ÛŒØ¯ Ù‚Ø¨Ù„ÛŒ Ø´Ù…Ø§)"
        await query.message.reply_text(invoice, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ØªØ§ÛŒÛŒØ¯ Ùˆ Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª âœ…", callback_data="show_card")]]), parse_mode='HTML')

    elif query.data.startswith("del_"):
        _, cat, pid = query.data.split("_")
        db["categories"][cat] = [p for p in db["categories"][cat] if str(p['id']) != pid]
        save_db(db)
        await query.message.edit_text("âœ… Ù¾Ù„Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯.")

    elif query.data.startswith("buy_"):
        _, cat, pid = query.data.split("_")
        plan = next(p for p in db["categories"][cat] if str(p['id']) == pid)
        user_data[uid] = {'step': 'get_name', 'plan': plan, 'is_new': True}
        await query.message.reply_text("ğŸ“ Ù†Ø§Ù… Ø§Ú©Ø§Ù†Øª Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯ (Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ):")

    elif query.data == "show_card":
        p = user_data[uid].get('price', 0)
        txt = f"ğŸ’³ Ú©Ø§Ø±Øª: <code>{db['card']['number']}</code>\nğŸ’° Ù…Ø¨Ù„Øº: {p:,} ØªÙˆÙ…Ø§Ù†\nğŸ‘¤ Ø¨Ù†Ø§Ù…: {db['card']['name']}"
        await query.message.reply_text(txt, parse_mode='HTML', reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ“¤ Ø§Ø±Ø³Ø§Ù„ ÙÛŒØ´", callback_data="get_photo")]]))

    elif query.data == "get_photo": await query.message.reply_text("ğŸ“¸ ÙÛŒØ´ Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯:")

    elif query.data.startswith("adm_ok_"):
        target = query.data.split("_")[2]
        user_data[str(ADMIN_ID)] = {'step': 'send_cfg', 'target': target, 
                                   'vol': user_data[target].get('vol'), 
                                   'vpn_name': user_data[target].get('vpn_name'), 
                                   'price': user_data[target].get('price'),
                                   'is_new': user_data[target].get('is_new', False)}
        await query.message.reply_text(f"Ù„ÛŒÙ†Ú© Ø±Ø§ Ø¨Ø±Ø§ÛŒ {target} Ø¨ÙØ±Ø³ØªÛŒØ¯:")

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = str(update.message.from_user.id)
    if user_data.get(uid, {}).get('step') == 'wait_pay':
        await context.bot.send_photo(ADMIN_ID, update.message.photo[-1].file_id, 
                                     caption=f"ÙÛŒØ´ Ø§Ø² {uid}\nÙ…Ø¨Ù„Øº: {user_data[uid].get('price', 0):,}Øª",
                                     reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("âœ… ØªØ§ÛŒÛŒØ¯", callback_data=f"adm_ok_{uid}")]]))
        await update.message.reply_text("ğŸš€ ÙÛŒØ´ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯. Ù…Ù†ØªØ¸Ø± ØªØ§ÛŒÛŒØ¯ Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø§Ø´ÛŒØ¯.")

if __name__ == '__main__':
    Thread(target=run_web, daemon=True).start()
    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_msg))
    app.add_handler(CallbackQueryHandler(handle_call))
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    app.run_polling(drop_pending_updates=True)
